# goit-algo-hw-06
algo_homework 6_graph

Task 1.

Вибір реальної мережі
Ми змоделюємо транспортну мережу невеликого міста, де:

 - Вершини графа — це ключові транспортні вузли (зупинки чи перехрестя).
 - Ребра графа — це дороги між цими вузлами.

Приклад вузлів і доріг:

 - Вузли: A, B, C, D, E, F (зупинки чи райони).
 - Ребра: дороги з відповідними відстанями, наприклад, між A та B — 5 км.

   Висновки
1. Характеристики графа:

 - Граф містить 6 вузлів (транспортні точки) і 7 ребер (дороги).
 - Ступінь кожної вершини показує кількість доріг, що з’єднують цю точку з іншими.

2. Реальне застосування:

 - Такі графи можуть використовуватися для моделювання маршрутів у транспортній системі, пошуку найкоротших шляхів тощо.

Task 2.
Порівняння DFS та BFS для знаходження шляхів у графі.
Ми будемо використовувати граф, створений у першому завданні. Для цього ми допишемо код із використанням алгоритмів глибини першого пошуку (DFS) та ширини першого пошуку (BFS). Потім порівняємо результати обох алгоритмів.

Теоретична частина
1. DFS (Depth-First Search) — алгоритм, який досліджує граф у глибину. Він відвідує одну вершину і продовжує рухатися до сусідніх вершин, доки це можливо. Якщо шлях закінчується, алгоритм повертається назад і досліджує інший шлях.

 - Реалізується за допомогою стека (явного або за рахунок рекурсії).
 - Шляхи можуть бути довшими, оскільки алгоритм прагне до максимальної глибини.

2. BFS (Breadth-First Search) — алгоритм, який досліджує граф у ширину. Він спочатку відвідує всіх сусідів поточної вершини, перш ніж перейти до наступного рівня.

 - Реалізується за допомогою черги.
 - Знаходить найкоротший шлях між початковою та кінцевою точкою (у графі без ваг).

Практична частина: Реалізація коду
Крок 1: Створення базового графа
Ми використовуємо граф із першого завдання. Якщо його код не підключено, додамо функцію create_transport_graph().

Крок 2: Реалізація алгоритмів DFS та BFS
Додамо функції для виконання пошуку шляхів у графі.

Крок 3: Виклик обох алгоритмів та порівняння їх результатів

Пояснення коду
1. Створення графа:
Ми використовуємо функцію create_transport_graph(), щоб створити транспортний граф із вершинами (A, B, ...). Ребра описують зв'язки між транспортними точками.

2. DFS і BFS:

 - У DFS використовуємо стек для збереження поточного вузла і шляху до нього.
 - У BFS використовуємо чергу, щоб пройти всі сусіди кожної вершини.

3. Візуалізація:
Граф візуалізується через networkx і matplotlib.

4. Порівняння:
У функції compare_algorithms() ми викликаємо обидва алгоритми і порівнюємо результати, виводячи їх у термінал.

Очікуваний результат:
Для графа із кодом:

 - DFS: Шлях може бути, наприклад, ['A', 'C', 'E', 'F', 'G'].
 - BFS: Шлях, ймовірно, буде найкоротшим: ['A', 'C', 'E', 'G'].
Ми бачимо, як BFS завжди повертає найкоротший шлях, тоді як DFS знаходить шлях, залежно від порядку обходу.

Task 3.
У цьому завданні ми реалізуємо алгоритм Дейкстри, який використовується для знаходження найкоротшого шляху в графі з вагами. Додамо ваги до графа, створеного в попередніх завданнях, і знайдемо найкоротші шляхи між усіма вершинами.

Теоретична частина:
1. Алгоритм Дейкстри:

 - Це жадібний алгоритм для знаходження найкоротшого шляху від однієї вершини до всіх інших у графі з невід'ємними вагами.
 - Працює шляхом поступового розширення множини вершин, для яких відомі найкоротші шляхи.
 - Використовує чергу з пріоритетами для ефективного вибору вершини з мінімальною відстанню.

2. Ключові поняття:

 - Вага ребра: число, яке визначає "вартість" переходу між двома вершинами.
 - Відстань: сума ваг ребер між початковою і кінцевою точками.

Практична частина: Реалізація алгоритму

Крок 1: Модифікація графа
До графа потрібно додати ваги для кожного ребра. Це можна зробити за допомогою функції add_edge із зазначенням атрибуту weight.

Крок 2: Реалізація алгоритму Дейкстри
Напишемо функцію dijkstra, яка:

 - Приймає граф, початкову вершину, та повертає найкоротші відстані до всіх інших вершин.

Крок 3: Виведення результатів
Знайдемо найкоротший шлях для всіх вершин графа і виведемо результати.

Пояснення коду
1. Створення графа:

 - Функція create_weighted_graph() створює граф із вагами для кожного ребра (атрибут weight).
 - Наприклад, ребро між "A" і "B" має вагу 4.

Алгоритм Дейкстри:

 - Використовує словник distances для зберігання найкоротших відстаней від початкової вершини до кожної іншої.
 - Черга з пріоритетами (heapq) дозволяє ефективно вибирати вершину з мінімальною відстанню.
 - Для кожного сусіда перевіряємо, чи можна скоротити шлях, і, якщо так, оновлюємо відстань.

3. Візуалізація графа:

 - Ми виводимо граф із підписами ваг ребер, щоб наочно бачити транспортну мережу.

4. Результат:

 - Для кожної вершини виводиться мінімальна відстань від початкової вершини.
